#summary Notification (STM version of condition variables)

= Introduction =

Just as with traditional lock based approaches, notification between transactions can be very useful (e.g. to wake up when an item has been placed on a queue). But unlike the explicit condition variables in lock based approach, STM's can do this completely behind the screens. At the moment Multiverse only supports the retry.

An example:
A latch is a structure that can be seen as a door that is closed. As long as the latch is closed, a thread that wants to enter the door needs to wait until it is opened. Once the Latch is opened, the threads are woken up. And the door of a Latch can never be closed.


Example in old school Java:

{{{
public class Latch{
   private volatile isOpen = false;

   public boolean isOpen(){
      return isOpen;
   }

   public void open(){
       synchronized(this){
          isOpen = true;
          notifyAll();
       }
   }

   public void await()throws InterruptedException{
       if(isOpen){
           return;
       }

       synchronized(this){
           while(!isOpen)
              await();
       }
   }
}
}}}

The same example in Multiverse:
{{{
public class Latch{
   private isOpen = false;

   public boolean isOpen(){
      return isOpen;
   }

   public void open(){
      isOpen = true;       
   }

   public void await(){
       if(!isOpen){
           retry();
       }
   }
}
}}}

== Waiting on multiple condition ==

With traditional lock based approaches, it is very hard to wait on multiple wait sets. So if you have 2 stacks for example, and you want to wake up when an item is placed on one of those stacks, you have a hard problem to fix. This is caused by that each stack has its own Lock and Waitset and a thread can also be placed in a single waitset. So the thread is either waiting in the waitset from stack1 (and ignoring notifications in the waitset of stack2) or the other way around. 

With an SMT this is not needed and you could say something like this:

{{{
E pop(){
    if(!stack1.isEmpty())
        stack1.pop();
    if(!stack2.isEmpty())
        stack2.pop();
    retry();
}
}}}

If no items is available on the stacks, the transaction is retried. And since the transaction knows which objects are able to change (the ones you have read), it registers itself as a listener to these structures. And as soon as a change is made on one of the two stacks, the transaction is retried.

= Planned: orelse =

Support for the orelse is planned. The orelse is a 'construct' that makes it possible to try an alternative path if some path can't complete.

Example of an orelse:

{{{
E popFromSomeStack(){
   {
      return stack1.pop();
   }orelse{
      return stack2.pop();
   }
}
}}}

If the stack1.pop fails with an retry, the path containing stack2 can be tried. If you are lucky stack2 contains an item. And if you are unlucky stack2 doesn't contain an item and the transaction needs to be retried as soon as either stack1 or stack2 has change.

There are 2 problems that need to be solved with the orelse implementation:
   * The limitations of the Java language makes it hard to create a syntax friendly version of the orelse. Good idea's are appreciated.
   * Changes made in one path within a transaction are not rolled back. So for the orelse a new transaction is needed that knows to execute the second path. So there is quite some overhead. 