#summary Overview of the (planned) features of Multiverse

= Features =
  * multi version concurrency control (the same mechanism Oracle, Postgresql and other databases use). So readers don't block writers, and writers don't block readers. And transactions with non conflicting writes can be committed in parallel.
  * no overhead on reads/writes of object fields that point to primitives or non stm objects. Instead of working with a transaction log, the object is checked for changes when the commit happens. So all classic compiler optimisations are not obstructed in any way.
  * small overhead (for lazy loading purposes) on mutable stm references. 
  * special optimisations for immutable stm structures so that loading gets really cheap (O(c)) no matter the size of the structure.
  * non managed stm objects can flow through stm space (for example for handing over an object from one thread to another).
  * transaction level read consistency (the same isolation Oracle provides, so not 100% serialized)
  * supports the retry

= Planned =
  * Pessimistic locking & deadlock detection 
  * Instrumentation of pojo's. At the moment the main goal is to create a good Stm implementation and that is why classes need to be 'instrumented' manually (so implement the interfaces on the pojo's). Once the Stm is nearing completion, the instrumentation will be added. 
  * Annotation driven transaction instead of the current template driven version
  * A lot of statistics to help developers figure out what goes on and how to improve performance.
  * support for OrElse (is peanuts).
  * readonly transactions
  * garbage collection of non references stm content. Once the objects are committed, they are dehydrated and the heap is pointing to them so the gc won't throw them away even though they are not used anymore.
  * nested transactions
  * detachment and reattachment of stm objects