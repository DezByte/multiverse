#summary Annotation based configuration
#sidebar TableOfContents
<wiki:toc max_depth="1" />

= Transaction =

If a method needs to be transactional, this can be done with the @Atomic annotation, example:

{{{
import org.multiverse.collections.Queue;

...

private Handle<Queue<String>> queueHandle;

@Atomic
public void createQueue(){
    queueHandle = getTransaction().attach(new Queue<String>());
}

@Atomic
public void storeItem(String item){
    Queue<String> queue = getTransaction().read(queueHandle);
    queue.push(item);
}

}}}

This annotation will make sure that a transaction is started and committed, or retried when needed. In the future the @Atomic annotation will contain all kinds of configuration options like the maximum number of retries, delays between retries, total timeout time, propagation etc.

It is also important to realize that not every method needs to be @Atomic; only the 'outer' methods of your system. Exactly the same as with classic database transactions where, in most cases, you only make the methods of the service layer transactional.

= Mapping an entity =

A Entity (an object that lives in STM space) can be configured by placing an @TmEntity annotation, example:

{{{
@TmEntity
public class Account{

   private int amount;
   ...
}
}}}

When this object is attached to a transaction, it will be persisted (to shared memory) when the transaction is committed. If an entity has a reference to one or more other entities, they will be persisted as well, example: 

{{{
@TmEntity
public class Person{
   
    private Account account;
    ...
}
}}}

So there is no need to attach each object individually to a transaction.

= Ignoring fields = 

Normally all fields of an object will be stored in STM space. But in some cases it is better to ignore a field. This can be done with the @Ignore annotation, example:

{{{
@TmEntity
public class Person{

   @Ignore
   private String firstname;

   private String lastname;
 
   ...
}
}}}

In this case the firstname is completely ignored and the lastname is not ignored.

= Preventing transaction overload =

Normally all objects that are loaded from a transaction, are stored in the transaction. This is done for 2 reasons:
  # when the transaction commits, it can find these objects and knows that these need to be committed if they are dirty.
  # multiple requests for the same instance, give the same instance.
But the problem is that this helpful behaviour causes cpu and memory overhead. Luckily there are a lot of cases where this behaviour is not needed, example:

{{{
@TmEntity
public class Stack{

   private Node head;

   public void push(Object item){
         head = new Node(head, item);
   }

   public void pop(){
      if(head == null){
          retry();
      }

      Node oldHead = head;
      head = head.next;
      return oldHead.item;
   }

   @TmEntity
   private class Node{

       private Node next;

       private Object item;

       private Node(Node next, Object item){
          this.next = next;
          this.item = item;
       }
   }
}
}}}

In this case a head or next will only be loaded once so there is no reason to add every node to the transaction. And because the stack has a reference to the head, and a head to each next node, all changes will be persisted when the transaction commits. Again there is no reason to store this information in the transaction. That is why the @Unmanaged annotation is added, example:

{{{
@TmEntity
public class Stack{

   @Unmanaged
   private Node head;

   public void push(Object item){
         head = new Node(head, item);
   }

   public void pop(){
      if(head == null){
          retry();
      }

      Node oldHead = head;
      head = head.next;
      return oldHead.item;
   }

   @TmEntity
   private class Node{
       
       @Unmanaged
       private Node next;

       private Object item;

       private Node(Node next, Object item){
          this.next = next;
          this.item = item;
       }
   }
}
}}}
The @Unmanaged annotation is perfect for inner objects that won't escape the outer object and where the outer object will keep a reference to the inner objects (directly or indirectly). In the future this information could be retrieved by escape analysis, but for now the @Unmanaged annotation is a good solution.

= Annotations planned =

Annotations planned for future releases:
  # @Lock(mode=LockMode.exclusive), @Lock(mode=LockMode.shared) 
  # @Immutable, to indicate that an entity (and everything that can be reached from it) is immutable. This is useful for improving performance.
  # Eager for eager loading of references when lazy loading is not needed