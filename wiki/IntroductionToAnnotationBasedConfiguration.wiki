#summary Annotation based configuration
#sidebar TableOfContents
<wiki:toc max_depth="1" />

= Transaction =

If a method needs to be transactional, this can be done with the @AtomicMethod annotation, example:

{{{
import org.multiverse.datastructures.collections.DoubleLinkedQueue;

...

private DoubleLinkedQueue<String> queueHandle;

@AtomicMethod
public void createQueue(){
    queue = new DoubleLinkedQueue();
}

@AtomicMethod
public void storeItem(String item){
    queue.push(item);
}

}}}

This annotation will make sure that a transaction is started and committed, or retried when needed. In the future the @AtomicMethod annotation will contain all kinds of configuration options like the maximum number of retries, delays between retries, total timeout time, propagation etc.

It is also important to realize that not every method needs to be @AtomicMethod; only the 'outer' methods of your system. Exactly the same as with classic database transactions where, in most cases, you only make the methods of the service layer transactional.

= Mapping an entity =

A Entity (an object that lives in STM space) can be configured by placing an @AtomicObject annotation, example:

{{{
@AtomicObject
public class Account{

   private int amount;
   ...
}
}}}

When this object is attached to a transaction, it will be persisted (to shared memory) when the transaction is committed. If an entity has a reference to one or more other entities, they will be persisted as well, example: 

{{{
@AtomicObject
public class Person{
   
    private Account account;
    ...
}
}}}

So there is no need to attach each object individually to a transaction. 

All changes made on objects attached/loaded directly/indirectly will be committed atomic, consistent and isolated. So just as with a database, a lot of responsibilities have shifted from the developer to the environment. And only in corner cases you need to influence the implementation.

= Final fields and AtomicObjects =

Final fields in AtomicObjects are completely ignored by the STM. If an AtomicObject only contains final/excluded fields, the object becomes invisible to the STM (although the methods still are atomic). So immutable datastructures can be perfectly combined with STM techniques. So don't throw immutable datastructures out of the window.

= Excluding fields = 

Normally all fields of an object will be stored in STM space. But in some cases it is better to exclude a field. This can be done with the @Exclude annotation, example:

{{{
@AtomicObject
public class Person{

   @Exclude
   private String firstname;

   private String lastname;
 
   ...
}
}}}

In this case the firstname is ignored and the lastname is not ignored.

The @Exclude annotation can be compared to the @Transient annotation from JPA.

= Annotations planned =

Annotations planned for future releases:
  # @Lock(mode=LockMode.exclusive), @Lock(mode=LockMode.shared) 
  # @Immutable, to indicate that an entity (and everything that can be reached from it) is immutable. This is useful for improving performance.
  # Eager for eager loading of references when lazy loading is not needed