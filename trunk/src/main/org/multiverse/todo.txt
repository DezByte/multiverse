---------------------------------------------------------------
todo engine
---------------------------------------------------------------


- flashback transactions test

- RetrySpinningWriteSetLockPolicy

- SpinningWriteSetlockPolicy unit tests

- BalancedTree moet nog rotatie hebben

- FastTom.registerRetryListener en de noProgressPossibleException

- FastTomTest afmaken

- IntValuePerformanceTest moet naar benchy geport worden.

- CigaretteSmokersProblemSimplifiedTest

- move the benchmarks to this project
    - depends on instrumentation

- build maken waarin de revisie nummer verwerkt zit.

---------------------------------------------------------------
todo instrumentation
---------------------------------------------------------------

- there is a difference in using an instrumented IntRef or an manual instrumented IntRef.
Some integration tests fail while using the former one.

- detection

    - this calling constructor should be detected.

    - non static inner classes should be detected

- testCreateAtomicObjectInConstructor

- er gaat is mis met een private method van een tranlocal. Dit heeft te maken
met het feit dat de opcode INVOKESPECIAL is, ipv INVOKEVIRTUAL wat nodig is
voor een non private method.

- swappen bij de managedfieldremappingadapter kan voor problemen zorgen bij longs/doubles


- vanuit een aangepaste method gaan de calls naar in tranlocalform, terwijl
de callee's in atomicobject vorm verwacht.

- cycles tussen classes, instrumentatie kan daar nog niet goed mee om gaan.

- problemen met non static inner classes van AtomicObjects. Deze inner classes verwijzen voor
de outerclass nog steeds naar de AtomicObject, en niet naar de Tranlocal

    - atomicMethodWithAtomicTemplateDoesntCauseHarm

    - code from the construtor in the mixin is discarded


- readonly advice moet weer op de tranlocal gezet worden

- constructors & atomic

    - constructors en atomic kunnen niet goed omgaan met  this calls

    - gewoon de waarde van de argumenten evalueren en die voor zowel de echte class
    als de translocal gebruikt worden om de constructor aan te roepen.

    - atomic en constructors werk niet goed mbt instrumentatie.. Class validate fout

        -de PipelineLongTest geeft bij het debuggen een :
        java.lang.ClassFormatError: Invalid length 65519 in LocalVariableTable in class file org/multiverse/integration/PipelineLongTest
        Dit komt door de atomicclassfiletransformer aangezien dat de enigste instrumentatie is die er nu in zit.

- testen dat een synchronized op een atomic method, gewoon gebruikt blijft worden en
niet per ongeluk weg valt door de instrumentatie en het copieeren.

- testen wat er gebeurd bij een duplicate field.. dus als je een field toevoegd doe ook al in
de mixin zit.

- testen wat er gebeurd bij een duplicate method... dus als een method toevoegd doe ook al
in de mixin zit.

- stm exectutor aanpassen zodat hij op de instrumentatie werkt.

---------------------------------------------------------------
todo features
---------------------------------------------------------------

- excluded packages in the AbstractClassFileTransformer should be configurable

- name on transaction

- retry limit in instrumentation needs to be added

- retry limit on atomictemplate.

- support for real serialized isolation level

- history for stale objects

- customizable contention managers 

- pessimistic online locking

- nested transactions

- SkipList

- better queue that allows better concurrency.

---------------------------------------------------------------
idea:
---------------------------------------------------------------

- a ref stm that is completely optimized for refs without notification support.

- instead of using the StmUtils.privatize, generate the code inline

- insead of using the SmtUtils.attachAsNew, generate the code inline

- instead of having a locked bit, the tranlocal could have access to the transaction. Once committed,
this reference can be set to null. Can also be used for detecting if a tranlocal can in from a different
transaction.

- provide as much as possible to point to failures in the byteocode (missing
parts for example) which class/method it was.. for debugging purposes ofcourse

- idee om plementatie specific details eruit te laten:
de interfaces zo maken zodat multiverse 0.2 er ook in gebouwd had kunnen worden
- a performance test comparing the 'managed ref' approach vs the full blown multiverse approach.

- a performance comparison between 'uninstrumented' code and instrumented code.

- statistics about number of loads that could get information from the transaction instead
of loading from main memory. This is also needed for optimizing bytecode.

- Commute Clojure nazoeken

- after commit event (for example for starting threads).

- could the abort and retry mechanism be implemented more efficiently? Atm the whole transaction
is aborted and the complete transaction needs to be re-done. A more efficient implemention could block
and wait until a write has happened on some field and continue with the operation, just like a classic
wait/notify.

- more efficient wait/notify: for example the balancedtree and sleeping for a specific key. Atm
all objects loaded by a transaction are a reason to wake up (cause a change happens on them). But
what if you are only interested in a specific field... this could reduce the stress on the mechanism

- logging instrumentation: instrumentation that adds logging.

- transaction level statistics

- jmx component om statistics grafisch inzichtelijk te maken

- door onderscheid te maken tussen attachednew en loaded, zou je eventueel nog optimalisaties kunnen doen:
     - op nieuw objecten hoef je geen lock aan te vragen
     - op nieuw objecten hoef je niet te valideren
     - op nieuw objecten hoef je geen lock te releasen
     - op nieuw objecten hoef je je niet druk te maken over retrylisteners

- online pessimistic locking

- Optimization for transaction usage

via DebugConstants er in laten genereren
- exceptions opnieuw aanmaken of bestaande instance hergebruiken:

- te kijken wat te doen met de exception hierarcy.. zoals moeten andere exceptions extenden van abortexception and
retryerror?

- bloomfilter

- heeft het nu om een read op een writetransactie te hebben terwijl je de $readPrivatized daar ook al hebt?

- abort silently

- retry moet gebeuren als er een write is gebeurd

- ipv de cheap latch zou je ook de monitor lock van de transactie kunnen gebruiken.
Dit scheelt nog een object creatie.

- enchance the $Object structure so that it also can be used for tree (replacement for the identity hashmap)

- timeout tijd.. spaarrekening waar je iedere keer vanaf kunt boeken.

- de timeout tijds op de locks zetten

- een abortAndRetry interruptibly?

- abort en retry met timeouts?

- managed ref annotation: by setting a ref, you don't force an object to an atomic object
but a normal object using a managed ref.

---------------------------------------------------------------
done
---------------------------------------------------------------

 - what is essential for the tranlocal interface? Atm there is an abstract class
    with implementation specific stuff in it. If the tranlocal interface is moved, also the
    dirtninessstatus can be moved.

- Translocal moves to the stm.alpha package

- TranlocalSnapshot moved to the stm.alpha package

- DirtinessState moved to the stm.alpha package.

- constructors en atomic kunnen niet goed omgaan met  super calls

- the atomic template ignorethreadlocaltransaction is activated again.

- what happens when a throwable is thrown while executing the orelse template. if the throwable
is caught, it leaves the transaction in an inconsistent state.

- checkin op subversion

- stm utils has dependencies to the alpha package

- LOAD PROBLAMTIEK
    - it could happen that a readonly transaction fails because it reads a TransactionalObject that
    is locked.
    + privatize functie aanpassen zodat fail fast.
    + it could happen that a writetransaction fails with the privatized call because it reads a
    TransactionalObject that is locked.
    + wat moet er gebeuren als een transactie een load doet op uncommitted data.
    + opgelost in de code
    + opgelost in de documentatie van de load methodes
    + opgelost in de code van andere methodes behalve de loadmethods van de transactie.
    + privatize functie moet aangepast worden zodat er een loaduncommitted wordt gegooid?
    + documentatie
    + unit tests

- the Transaction interface contains load/privatize methods which are implementation specific.

- added a retry limit on the AtomicTemplate.

- the lock manager has reference to alpha package (translocal)

- de integration package die heeft verwijzingen naar de alpha package

- exceptions in the exception package zijn afhankelijk van de alpha package
