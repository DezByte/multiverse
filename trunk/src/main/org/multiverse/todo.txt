---------------------------------------------------------------
todo engine
---------------------------------------------------------------

- this calling constructor
    - atomicmethod

- atm only atomic methods inside atomic object are enhanced so that the takes and puts are transformed.
  But this should be all code.

- javadoc publishen op de site

- FastTom.registerRetryListener and noProgressPossibleException

- FastTomTest finish

- IntValuePerformanceTest port to benchy

- CigaretteSmokersProblemSimplifiedTest

- move the benchmarks to this project
    - depends on instrumentation

- naamgeving van de 'retry' (blocking) functionality aanpassen aangezien het enorm misleidend is.

- cycles tussen classes, instrumentatie kan daar nog niet goed mee om gaan.


---------------------------------------------------------------
todo instrumentation
---------------------------------------------------------------

- there is a difference in using an instrumented IntRef or an manual instrumented IntRef.
Some integration tests fail while using the former one.

- testCreateAtomicObjectInConstructor

- code from the construtor in the mixin is discarded

- testen wat er gebeurd bij een duplicate field.. dus als je een field toevoegd doe ook al in
de mixin zit.

- testen wat er gebeurd bij een duplicate method... dus als een method toevoegd doe ook al
in de mixin zit.

---------------------------------------------------------------
todo features
---------------------------------------------------------------

- writing instrumented class to the out should be configurable.

- excluded packages in the AbstractClassFileTransformer should be configurable

- support for real serialized isolation level

- history for stale objects

- customizable contention managers 

- pessimistic online locking

- nested transactions

- SkipList

---------------------------------------------------------------
idea:
---------------------------------------------------------------

- a ref stm that is completely optimized for refs without notification support.

- instead of having a locked bit, the tranlocal could have access to the transaction. Once committed,
this reference can be set to null. Can also be used for detecting if a tranlocal can in from a different
transaction.

- provide as much as possible to point to failures in the byteocode (missing
parts for example) which class/method it was.. for debugging purposes of course

- a performance test comparing the 'managed ref' approach vs the full blown multiverse approach.

- a performance comparison between 'uninstrumented' code and instrumented code.

- statistics about number of loads that could get information from the transaction instead
of loading from main memory. This is also needed for optimizing bytecode.

- Commute Clojure nazoeken

- after commit event (for example for starting threads).

- could the abort and retry mechanism be implemented more efficiently? Atm the whole transaction
is aborted and the complete transaction needs to be re-done. A more efficient implemention could block
and wait until a write has happened on some field and continue with the operation, just like a classic
wait/notify.

- more efficient wait/notify: for example the balancedtree and sleeping for a specific key. Atm
all objects loaded by a transaction are a reason to wake up (cause a change happens on them). But
what if you are only interested in a specific field... this could reduce the stress on the mechanism

- transaction level statistics

- door onderscheid te maken tussen attachednew en loaded, zou je eventueel nog optimalisaties kunnen doen:
     - op nieuw objecten hoef je geen lock aan te vragen
     - op nieuw objecten hoef je niet te valideren
     - op nieuw objecten hoef je geen lock te releasen
     - op nieuw objecten hoef je je niet druk te maken over retrylisteners

- online pessimistic locking

- Optimization for transaction usage

- bloomfilter

- abort silently

- retry moet gebeuren als er een write is gebeurd

- ipv de cheap latch zou je ook de monitor lock van de transactie kunnen gebruiken.
Dit scheelt nog een object creatie.

- timeout tijd.. spaarrekening waar je iedere keer vanaf kunt boeken.

- de timeout tijds op de locks zetten

- een abortAndRetry interruptibly?

- abort en retry met timeouts?

- managed ref annotation: by setting a ref, you don't force an object to an atomic object
but a normal object using a managed ref.

---------------------------------------------------------------
done
---------------------------------------------------------------

- logging op readonly transactie

- controleren of readonly transacties ook worden voorzien van statistics

- readonly advice moet weer op de tranlocal gezet worden

- agent doesn't write to classfile anymore

- non static inner classe

- retry limit on atomictemplate.

- retry limit in instrumentation needs to be added