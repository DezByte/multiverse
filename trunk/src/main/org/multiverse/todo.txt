---------------------------------------------------------------
todo engine
---------------------------------------------------------------

- readonly annotation

- FastTom.registerRetryListener en de noProgressPossibleException

- FastTomTest afmaken

- IntValuePerformanceTest moet naar benchy geport worden.

- CigaretteSmokersProblemSimplifiedTest

- move the benchmarks to this project
    - depends on instrumentation

---------------------------------------------------------------
todo instrumentation
---------------------------------------------------------------

- there is a difference in using an instrumented IntRef or an manual instrumented IntRef.
Some integration tests fail while using the former one.

- detection

    - this calling constructor should be detected.

    - non static inner classes should be detected

- testCreateAtomicObjectInConstructor

- er gaat is mis met een private method van een tranlocal. Dit heeft te maken
met het feit dat de opcode INVOKESPECIAL is, ipv INVOKEVIRTUAL wat nodig is
voor een non private method.

- swappen bij de managedfieldremappingadapter kan voor problemen zorgen bij longs/doubles


- vanuit een aangepaste method gaan de calls naar in tranlocalform, terwijl
de callee's in atomicobject vorm verwacht.

- cycles tussen classes, instrumentatie kan daar nog niet goed mee om gaan.

- problemen met non static inner classes van AtomicObjects. Deze inner classes verwijzen voor
de outerclass nog steeds naar de AtomicObject, en niet naar de Tranlocal

    - atomicMethodWithAtomicTemplateDoesntCauseHarm

    - code from the construtor in the mixin is discarded


- readonly advice moet weer op de tranlocal gezet worden

- constructors & atomic

    - constructors en atomic kunnen niet goed omgaan met  this calls

    - gewoon de waarde van de argumenten evalueren en die voor zowel de echte class
    als de translocal gebruikt worden om de constructor aan te roepen.

    - atomic en constructors werk niet goed mbt instrumentatie.. Class validate fout

        -de PipelineLongTest geeft bij het debuggen een :
        java.lang.ClassFormatError: Invalid length 65519 in LocalVariableTable in class file org/multiverse/integration/PipelineLongTest
        Dit komt door de atomicclassfiletransformer aangezien dat de enigste instrumentatie is die er nu in zit.

- testen dat een synchronized op een atomic method, gewoon gebruikt blijft worden en
niet per ongeluk weg valt door de instrumentatie en het copieeren.

- testen wat er gebeurd bij een duplicate field.. dus als je een field toevoegd doe ook al in
de mixin zit.

- testen wat er gebeurd bij een duplicate method... dus als een method toevoegd doe ook al
in de mixin zit.

- stm exectutor aanpassen zodat hij op de instrumentatie werkt.

---------------------------------------------------------------
todo features
---------------------------------------------------------------

- excluded packages in the AbstractClassFileTransformer should be configurable

- name on transaction

- retry limit in instrumentation needs to be added

- retry limit on atomictemplate.

- support for real serialized isolation level

- history for stale objects

- customizable contention managers 

- pessimistic online locking

- nested transactions

- SkipList

- better queue that allows better concurrency.

---------------------------------------------------------------
idea:
---------------------------------------------------------------

- if a familyName is missing when a transaction starts, it could be derived from the methodName and the
className. This only counts for AtomicMethods

- a ref stm that is completely optimized for refs without notification support.

- instead of using the StmUtils.privatize, generate the code inline

- insead of using the SmtUtils.attachAsNew, generate the code inline

- instead of having a locked bit, the tranlocal could have access to the transaction. Once committed,
this reference can be set to null. Can also be used for detecting if a tranlocal can in from a different
transaction.

- provide as much as possible to point to failures in the byteocode (missing
parts for example) which class/method it was.. for debugging purposes of course

- idee om plementatie specific details eruit te laten:
de interfaces zo maken zodat multiverse 0.2 er ook in gebouwd had kunnen worden
- a performance test comparing the 'managed ref' approach vs the full blown multiverse approach.

- a performance comparison between 'uninstrumented' code and instrumented code.

- statistics about number of loads that could get information from the transaction instead
of loading from main memory. This is also needed for optimizing bytecode.

- Commute Clojure nazoeken

- after commit event (for example for starting threads).

- could the abort and retry mechanism be implemented more efficiently? Atm the whole transaction
is aborted and the complete transaction needs to be re-done. A more efficient implemention could block
and wait until a write has happened on some field and continue with the operation, just like a classic
wait/notify.

- more efficient wait/notify: for example the balancedtree and sleeping for a specific key. Atm
all objects loaded by a transaction are a reason to wake up (cause a change happens on them). But
what if you are only interested in a specific field... this could reduce the stress on the mechanism

- logging instrumentation: instrumentation that adds logging.

- transaction level statistics

- jmx component om statistics grafisch inzichtelijk te maken

- door onderscheid te maken tussen attachednew en loaded, zou je eventueel nog optimalisaties kunnen doen:
     - op nieuw objecten hoef je geen lock aan te vragen
     - op nieuw objecten hoef je niet te valideren
     - op nieuw objecten hoef je geen lock te releasen
     - op nieuw objecten hoef je je niet druk te maken over retrylisteners

- online pessimistic locking

- Optimization for transaction usage

- bloomfilter

- heeft het nu om een read op een writetransactie te hebben terwijl je de $readPrivatized daar ook al hebt?

- abort silently

- retry moet gebeuren als er een write is gebeurd

- ipv de cheap latch zou je ook de monitor lock van de transactie kunnen gebruiken.
Dit scheelt nog een object creatie.

- timeout tijd.. spaarrekening waar je iedere keer vanaf kunt boeken.

- de timeout tijds op de locks zetten

- een abortAndRetry interruptibly?

- abort en retry met timeouts?

- managed ref annotation: by setting a ref, you don't force an object to an atomic object
but a normal object using a managed ref.

---------------------------------------------------------------
done
---------------------------------------------------------------

- the zip file needs to contain the multiverse directory and version.

- asm should be placed under a different package name so no writeconflicts can happen
http://code.google.com/p/jarjar/wiki/GettingStarted

- activate readonly support in the the TransactionTemplate

