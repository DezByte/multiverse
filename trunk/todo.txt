TODO


IDEAS

- 

- would it be possible to merge dehydratedcitizens? When 2 transactions commit and see that there is a object-level conflict
 , but not a field level conflict, on a dehydratedcitizen, the transaction aborts and is retried again. But could it be possible to create a new dehydratedcitizen
that is the merged version of the two cells. Since there is no conflict on field level.. could this give isolation problems?

- statisch about which classes/objects/fields has lead to a write conflict.

- memory indication of numbers of cells and content of each cell.

- improve concurrency: transaction.validate can be done under a readlock. the transaction.makePermanent can be
executed under a writelock.

-changes in arrays are not seen.

- when an object is modified, just like in oracle, the row can be locked exclusive. At the moment nothing is locked,
and conflicts are detected when the transaction commits. But with the lock happening as soon as an update occurs,
the chance of conflicts will decrease (other transactions are not able to make modifications).

- a 'read for update'. When an object is called with the read for update, the object is automatically locked when
it is read. A version with timeout configuration (no wait) could also be added.

-eenvoudig maken dat de beans opgewired kunnen worden vanuit spring bv.

- add qos observation to transactiontemplate.

- instead of waiting for a commit to find out that the transaction can't be comitted, it could be done
sooner. 

- 'condition' variables. When a transaction does a retry, the cells it has read must be monitored. As soon as
the value of one of the cells changes, the transaction should be given a new try.

- limit the size of the heap
    -number of cells
    -limit history length

- garbage collection on older versions of cells

- garbage collection on non reachable citizens in the stm.

- instead of using a cell per object field, an error could be used. On the first pos the newobjectmarker is found.
And on each subsequent field is a element of that array. This is just an idea, I have no idea about the impact
on memory usage of cpu usage. 

- readonly transactions: transactions that don't allow any writes. When to check it? On the commit? Or as soon
as a write occurs.

- nested transaction icm propagation.

- store the current transaction in a threadlocal? For nested transactions this also can be used (transactions can
be stacked).

- optimization. The validate method of Transactionized could do duplicate work for a single commit, because this
method can be called on the same method more than once if the root objects share objects (not uncommon).

- observation: number of reads/writes to stm from transaction

- add reason why a transaction is aborted

- transaction that only have done a reads, should not increase the commit nr.
    -all reads and writes should go through the transaction, not drectly to main memory because logging of
    reads and writes is going to be easier to add.

DONE

- hashset is replaced by an identifyhashset in the transaction of the multiversionedstm.

- observation: number of created transactions, number of comitted transactions, number of failed transactions

- retrieve the object based on a pointer. One of the problems is that within a single transaction, it should not
be allowed that 2 instances of the same 'object' exist.

- commit has to be threadsafe: or change (single thread) or read (multiple threads)

- stm version of the wait notify mechamism.
    -send an event when an update has been done to a specfic address

- the queuetest shows to many consumes of the same message. This looks like a problem.

- the stacktest shows that multiple consumes of same message (0). This looks like a problem. Perhaps this is causing
the issue with the queuetest as well.
    -vermoeden at the moment is dat het zit in de multiversionedcell

- memory indication of number of cells

- memory indication of number of cells and versions.

- has the version to be increased after every commit? (even readonly commits).

- numer of readonly transactions is very low
    - transactions for stacks and queues that retry, are aborted. so the readolytransactioncount is not
     increased

- what happens when a fresh object is connected to an attached object. Is the fresh object also attached?

